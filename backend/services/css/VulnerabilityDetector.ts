/**
 * Vulnerability Detector ‚Äî Static Analysis Engine
 * ==================================================
 * TrackCodex original IP. Does NOT use Shannon logic.
 *
 * Responsibilities:
 *  - Parse source files
 *  - Detect source/sink patterns per language
 *  - Construct data flow hypotheses
 *  - Generate VulnerabilityHypothesis objects for AHI validation
 */

// --- Types ---

export interface VulnerabilityHypothesis {
    filePath: string;
    lineNumber: number;
    endLine: number;
    codeSnippet: string;
    vulnerabilityType: VulnerabilityType;
    detectedPattern: string;
    source: string;
    sink: string;
    dataFlowPath: string;
    baseSeverity: "CRITICAL" | "HIGH" | "MEDIUM" | "LOW";
}

export type VulnerabilityType =
    | "SQL_INJECTION"
    | "XSS"
    | "COMMAND_INJECTION"
    | "PATH_TRAVERSAL"
    | "SSRF"
    | "AUTH_BYPASS"
    | "INSECURE_DESERIALIZATION"
    | "HARDCODED_SECRET"
    | "OPEN_REDIRECT"
    | "PROTOTYPE_POLLUTION";

// --- Detection Rules ---

interface DetectionRule {
    type: VulnerabilityType;
    severity: "CRITICAL" | "HIGH" | "MEDIUM" | "LOW";
    sources: RegExp[];
    sinks: RegExp[];
    patterns: RegExp[];
    languages: string[];
    description: string;
}

const DETECTION_RULES: DetectionRule[] = [
    // SQL Injection
    {
        type: "SQL_INJECTION",
        severity: "CRITICAL",
        sources: [
            /req\.(body|query|params|headers)\[?/,
            /request\.(body|query|params)/,
            /ctx\.(request|query|params)/,
        ],
        sinks: [
            /\.query\s*\(/,
            /\.execute\s*\(/,
            /\.raw\s*\(/,
            /\$\{.*\}.*(?:SELECT|INSERT|UPDATE|DELETE|FROM|WHERE)/i,
            /`[^`]*(?:SELECT|INSERT|UPDATE|DELETE|FROM|WHERE)[^`]*\$\{/i,
        ],
        patterns: [
            /(?:query|execute|raw)\s*\(\s*[`'"].*\$\{/,
            /(?:query|execute|raw)\s*\(\s*.*\+\s*(?:req|request|ctx)/,
            /(?:SELECT|INSERT|UPDATE|DELETE).*\+\s*(?:req|request|input|user)/i,
        ],
        languages: ["typescript", "javascript", "python"],
        description: "User input directly concatenated into SQL query",
    },

    // Cross-Site Scripting (XSS)
    {
        type: "XSS",
        severity: "HIGH",
        sources: [
            /req\.(body|query|params)/,
            /request\.(body|query|params)/,
        ],
        sinks: [
            /\.innerHTML\s*=/,
            /\.outerHTML\s*=/,
            /document\.write\s*\(/,
            /res\.send\s*\(.*req\./,
            /dangerouslySetInnerHTML/,
        ],
        patterns: [
            /innerHTML\s*=\s*.*(?:req|request|input|user)/,
            /res\.send\s*\(\s*.*\+\s*(?:req|request)/,
            /dangerouslySetInnerHTML\s*=\s*\{\s*\{\s*__html\s*:/,
        ],
        languages: ["typescript", "javascript"],
        description: "User input rendered without sanitization",
    },

    // Command Injection
    {
        type: "COMMAND_INJECTION",
        severity: "CRITICAL",
        sources: [
            /req\.(body|query|params)/,
            /process\.argv/,
            /request\.(body|query|params)/,
        ],
        sinks: [
            /child_process/,
            /exec\s*\(/,
            /execSync\s*\(/,
            /spawn\s*\(/,
            /os\.system\s*\(/,
            /subprocess\.(call|run|Popen)\s*\(/,
        ],
        patterns: [
            /exec\s*\(\s*[`'"].*\$\{/,
            /exec\s*\(\s*.*\+\s*(?:req|request|input|user)/,
            /execSync\s*\(\s*.*\+/,
        ],
        languages: ["typescript", "javascript", "python"],
        description: "User input passed to shell command execution",
    },

    // Path Traversal
    {
        type: "PATH_TRAVERSAL",
        severity: "HIGH",
        sources: [
            /req\.(body|query|params)/,
            /request\.(body|query|params)/,
        ],
        sinks: [
            /fs\.(readFile|writeFile|readFileSync|writeFileSync|createReadStream)\s*\(/,
            /path\.join\s*\(.*req\./,
            /path\.resolve\s*\(.*req\./,
        ],
        patterns: [
            /(?:readFile|writeFile|createReadStream)\s*\(.*(?:req|request)\./,
            /path\.(?:join|resolve)\s*\(.*(?:req|request)\./,
        ],
        languages: ["typescript", "javascript"],
        description: "User input used to construct file paths without validation",
    },

    // SSRF
    {
        type: "SSRF",
        severity: "HIGH",
        sources: [
            /req\.(body|query|params)/,
            /request\.(body|query|params)/,
        ],
        sinks: [
            /axios\.(get|post|put|delete|request)\s*\(/,
            /fetch\s*\(/,
            /http\.request\s*\(/,
            /https\.request\s*\(/,
            /got\s*\(/,
        ],
        patterns: [
            /(?:axios|fetch|got|http\.request)\s*\(\s*(?:req|request)\./,
            /(?:axios|fetch|got)\s*\(\s*.*\+\s*(?:req|request)/,
            /(?:axios|fetch|got)\s*\(\s*`.*\$\{.*(?:req|request)/,
        ],
        languages: ["typescript", "javascript"],
        description: "User-controlled URL passed to server-side HTTP request",
    },

    // Auth Bypass
    {
        type: "AUTH_BYPASS",
        severity: "CRITICAL",
        sources: [],
        sinks: [],
        patterns: [
            /(?:isAdmin|isAuthenticated|isAuthorized)\s*=\s*(?:true|req\.)/,
            /if\s*\(\s*(?:req\.headers\[['"]authorization['"]\])\s*\)\s*\{[\s\S]*?\}\s*(?:else\s*\{[\s\S]*?next\s*\(\s*\)\s*\})?/,
            /jwt\.verify\s*\([\s\S]*?catch\s*\([\s\S]*?next\s*\(\s*\)/,
            /\/\/\s*TODO:?\s*(?:add|implement|fix)\s*auth/i,
            /auth.*bypass/i,
        ],
        languages: ["typescript", "javascript"],
        description: "Authentication/authorization logic that can be bypassed",
    },

    // Hardcoded Secrets
    {
        type: "HARDCODED_SECRET",
        severity: "HIGH",
        sources: [],
        sinks: [],
        patterns: [
            /(?:api[_-]?key|apikey|secret[_-]?key|password|passwd|token|auth[_-]?token)\s*[:=]\s*['"]\w{8,}['"]/i,
            /AKIA[0-9A-Z]{16}/,
            /-----BEGIN (?:RSA |EC |DSA )?PRIVATE KEY-----/,
            /ghp_[A-Za-z0-9_]{36}/,
            /sk-[A-Za-z0-9]{20,}/,
        ],
        languages: ["typescript", "javascript", "python", "java", "go"],
        description: "Sensitive credential hardcoded in source code",
    },

    // Open Redirect
    {
        type: "OPEN_REDIRECT",
        severity: "MEDIUM",
        sources: [
            /req\.(body|query|params)/,
        ],
        sinks: [
            /res\.redirect\s*\(/,
            /response\.redirect\s*\(/,
            /window\.location\s*=/,
        ],
        patterns: [
            /res\.redirect\s*\(\s*(?:req|request)\./,
            /redirect\s*\(\s*.*\+\s*(?:req|request)/,
        ],
        languages: ["typescript", "javascript"],
        description: "User input used in redirect without validation",
    },

    // Prototype Pollution
    {
        type: "PROTOTYPE_POLLUTION",
        severity: "HIGH",
        sources: [
            /req\.(body|query|params)/,
        ],
        sinks: [
            /Object\.assign\s*\(/,
            /\.\.\.\s*req\./,
            /merge\s*\(/,
            /extend\s*\(/,
            /defaultsDeep\s*\(/,
        ],
        patterns: [
            /Object\.assign\s*\(\s*\{\s*\}\s*,\s*(?:req|request)\./,
            /\.\.\.\s*(?:req|request)\.body/,
            /(?:merge|extend|defaultsDeep)\s*\(\s*.*,\s*(?:req|request)\./,
        ],
        languages: ["typescript", "javascript"],
        description: "User input merged into object without prototype protection",
    },
];

// --- Detector Class ---

export class VulnerabilityDetector {
    /**
     * Scan a set of files and generate vulnerability hypotheses.
     */
    static detect(
        files: Array<{ path: string; content: string; language: string }>
    ): VulnerabilityHypothesis[] {
        const hypotheses: VulnerabilityHypothesis[] = [];

        for (const file of files) {
            const fileHypotheses = this.analyzeFile(file);
            hypotheses.push(...fileHypotheses);
        }

        console.log(
            `üïµÔ∏è [VulnerabilityDetector] Generated ${hypotheses.length} hypotheses from ${files.length} files`
        );

        return hypotheses;
    }

    /**
     * Analyze a single file for vulnerabilities.
     */
    private static analyzeFile(file: {
        path: string;
        content: string;
        language: string;
    }): VulnerabilityHypothesis[] {
        const hypotheses: VulnerabilityHypothesis[] = [];
        const lines = file.content.split("\n");

        for (const rule of DETECTION_RULES) {
            // Check language applicability
            if (!rule.languages.includes(file.language)) continue;

            // Check each pattern
            for (const pattern of rule.patterns) {
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    if (pattern.test(line)) {
                        // Extract surrounding context (5 lines before/after)
                        const startCtx = Math.max(0, i - 5);
                        const endCtx = Math.min(lines.length - 1, i + 5);
                        const snippet = lines.slice(startCtx, endCtx + 1).join("\n");

                        // Identify source and sink from context
                        const { source, sink } = this.identifySourceSink(
                            snippet,
                            rule,
                            line
                        );

                        // Build data flow path
                        const dataFlow = this.buildDataFlowPath(
                            lines,
                            i,
                            rule
                        );

                        hypotheses.push({
                            filePath: file.path,
                            lineNumber: i + 1,
                            endLine: endCtx + 1,
                            codeSnippet: snippet,
                            vulnerabilityType: rule.type,
                            detectedPattern: rule.description,
                            source: source || "User-controlled input",
                            sink: sink || "Dangerous function call",
                            dataFlowPath: dataFlow,
                            baseSeverity: rule.severity,
                        });

                        // Avoid duplicate findings on the same line for the same rule
                        break;
                    }
                }
            }
        }

        return hypotheses;
    }

    /**
     * Identify the source (input entry) and sink (dangerous call) in context.
     */
    private static identifySourceSink(
        snippet: string,
        rule: DetectionRule,
        triggerLine: string
    ): { source: string; sink: string } {
        let source = "";
        let sink = "";

        for (const srcPattern of rule.sources) {
            const match = snippet.match(srcPattern) || triggerLine.match(srcPattern);
            if (match) {
                source = match[0];
                break;
            }
        }

        for (const sinkPattern of rule.sinks) {
            const match = snippet.match(sinkPattern) || triggerLine.match(sinkPattern);
            if (match) {
                sink = match[0];
                break;
            }
        }

        return { source, sink };
    }

    /**
     * Build a simplified data flow path from source to sink.
     */
    private static buildDataFlowPath(
        lines: string[],
        triggerLine: number,
        rule: DetectionRule
    ): string {
        const flowSteps: string[] = [];
        const searchRange = 20;

        // Look backwards for source
        for (
            let i = Math.max(0, triggerLine - searchRange);
            i <= triggerLine;
            i++
        ) {
            for (const srcPattern of rule.sources) {
                if (srcPattern.test(lines[i])) {
                    flowSteps.push(
                        `L${i + 1}: [SOURCE] ${lines[i].trim().substring(0, 100)}`
                    );
                    break;
                }
            }
        }

        // Add trigger line
        flowSteps.push(
            `L${triggerLine + 1}: [TRIGGER] ${lines[triggerLine].trim().substring(0, 100)}`
        );

        // Look forward for sink
        for (
            let i = triggerLine;
            i < Math.min(lines.length, triggerLine + searchRange);
            i++
        ) {
            for (const sinkPattern of rule.sinks) {
                if (sinkPattern.test(lines[i]) && i !== triggerLine) {
                    flowSteps.push(
                        `L${i + 1}: [SINK] ${lines[i].trim().substring(0, 100)}`
                    );
                    break;
                }
            }
        }

        return flowSteps.join("\n‚Üí ");
    }
}
